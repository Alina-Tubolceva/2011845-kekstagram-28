//Функция для проверки длины строки

const checkString = (string, length) => string.length <= length; //с помощью св-ва length возвращаем количество элементов в массиве, для чего?

checkString('проверяемая строка', 18);

//Функция для проверки, является ли строка палиндромом

const isPalindrom = (string) => {
  const tempString = string
    .toLowerCase() //переводим в нижний регистр с помощью метода toLowerCase
    .replaceAll(' ', ''); //убираем пробелы с помощью метода replaceAll
  let reversString = ''; //объявляем переменную с помощью которой будем считывать слово в обратном порядке
  for (let i = tempString.length - 1; i >= 0; i--) { //почему tempString.length -1? почему запускаем от -1? это значит что запускаем с конца?
    reversString += tempString.at(i); //объединяем 2 строки? за счет метода at мы начинаем с последнего эл-та переданного массива?
  }
  return tempString === reversString; //завершаем и возвращаем значение фу-ии
};

isPalindrom('Лёша на полке клопа нашёл ');

// Функция, которая принимает строку, извлекает содержащиеся в ней цифры от 0 до 9 и возвращает их в виде целого положительного числа.Если в строке нет ни одной цифры, функция должна вернуть NaN:

const extractNumber = (string) => {
  if (typeof string === 'number') {
    return string;
  }

  let result = '';
  for (let i = 0; i < string.length; i++) {
    if (!Number.isNaN(parseInt(string.at(i), 10))) { //ф-я parseInt принимает строку в качестве аргумента и возвращает целое число с указанной системой счисления
      result += string.at(i); //в result записываем очередной символ
    }
  }

  return parseInt(result, 10);
};

extractNumber('2023 год');


// Функция, которая принимает три параметра: исходную строку, минимальную длину и строку с добавочными символами — и возвращает исходную строку, дополненную указанными символами до заданной длины.Символы добавляются в начало строки.Если исходная строка превышает заданную длину, она не должна обрезаться.Если «добивка» слишком длинная, она обрезается с конца.

const myPadStart = (string, minLength, pad) => {
  const actualPad = minLength - string.length; //вычисляем недостоющее кол-во символов

  if (actualPad <= 0) {
    return string;
  }

  return pad.slice(0, actualPad % pad.length) + pad.repeat(actualPad / pad.length) + string; //pad.slice(0, actualPad % pad.length) почему 0?
  /*метод pad заполняет текущую строку другой строкой; метод slice возвращает новый массив, содержащий копию части исходного массива; Метод repeat() конструирует и возвращает новую строку, содержащую указанное количество соединённых вместе копий строки*/
};

myPadStart('1', 4, '0');
